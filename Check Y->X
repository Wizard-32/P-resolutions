import numpy as np
import fractions

# asumes a, b are 1 x n arrays
def dot(a, b):
    return sum([a[i]*b[i] for i in range(len(a))])

def solve_in_rationals(A: np.ndarray, b: np.ndarray):
    d = int(np.rint(np.linalg.det(A)))
    sol = []
    for i in range(np.shape(A)[0]):
        Ai = np.copy(A)
        Ai[:, i] = b
        t = fractions.Fraction(int(np.rint(np.linalg.det(Ai))), d)
        sol.append(t.numerator)
        # sol.append((str(t.numerator) + '/' + str(t.denominator)))
    return [sol, t.denominator]

''' 
create intersection matrix
[[2,3],[1],[2]] is the matrix [X^2,1,1],[1,Y^2,0],[0,1,Z^2]
NOTE: CAN CONTROL INDEXING by changing last parameter to 0
'''
def inter_mat(self_inter, adj, indexing=1):
    n = len(adj)
    M = [[0]*n for i in range(n)]
    for i in range(n):
        M[i][i] = self_inter[i]
    for i in range(n):
        for x in adj[i]:
            M[i][x-indexing] = 1
    return M

def f(M):
    return [-2-M[i][i] for i in range(len(M))]

def coeff(M):
    A = np.array(M); B = np.array(f(M)) # Solve Ax = B
    d = np.linalg.det(A)
    sol = np.linalg.solve(d*A, B)
    # sol, d = solve_in_rationals(A,B) 
    return [sol, d]

'''
inX has indices of curves that are in X
'''
def pcoeff(M, surface, inX, indexing=1):
    A = np.array(M); B = np.array(f(M)) # Solve Ax = B
    # d = int(np.linalg.det(A))
    # sol = np.linalg.solve((1/d)*A, B)
    # sol = [int(np.rint(x)) for x in sol]
    d = int(np.linalg.det(A))
    sol = np.linalg.solve((1/d)*A, B)
    sol = [fractions.Fraction(int(np.rint(x)), d) for x in sol]
    # sol, denom = solve_in_rationals(np.array(M),np.array(f(M)))
    s = 'K_' + surface + ' = ('
    for i in range(len(sol)):
        if surface == 'X' and not i+indexing in inX:
            continue
        s += str(sol[i]) + 'C_' + str(i+indexing) + ' + '
    s = s[:-3]
    s += ')'
    print(s)

''' 
resolution Y -> X
neatly prints something like K = 1/5(2C_1 + 3C_2) 
'''
def giveKY(self_inter, adj, indexing=1):
    M = inter_mat(self_inter, adj, indexing)
    return pcoeff(M, 'Y', [], indexing)

# KX, prints after contracting all non (-1) curves in Y
def giveKX(self_inter, adj, inX, indexing=1):
    M = inter_mat(self_inter, adj, indexing)
    return pcoeff(M, 'X', inX, indexing)

'''
Find π^*(K_X)
'''
def pullbackK(self_inter, adj, inX, indexing=1):
    n = len(adj)
    exceptional = [i for i in range(n) if not (i+indexing) in inX] # exceptional is 0 indexed
    m = len(exceptional)
    M = [[0]*m for i in range(m)]
    for i in range(m):
        M[i][i] = self_inter[exceptional[i]]
    for i in range(m):
        for x in adj[exceptional[i]]:
            if x-indexing in exceptional:
                # print(i, exceptional.index(x))
                M[i][exceptional.index(x-indexing)] = 1  

    A = np.array(M); B = np.array(f(M)) # Solve Ax = B
    try: ## In case exceptional locus is empty
        d = int(np.linalg.det(A))
        sol = np.linalg.solve((1/d)*A, B)
        sol = [fractions.Fraction(int(np.rint(x)), d) for x in sol]
    except:
        d = 1
        sol = []
        
    s = 'π^* K_X = '
    for i in range(len(sol)):
        s += str(sol[i]) + 'C_' + str(exceptional[i]+indexing) + ' + '
    if len(sol) > 0:
        s = s[:-3]
    print(s) # prints equation
    return sol # returns array of coefficients

def checkAmple(self_inter, adj, inX, indexing=1):
    n = len(adj)
    exceptional = [i for i in range(n) if not (i+indexing) in inX] # exceptional is 0 indexed
    coefficients = pullbackK(self_inter, adj, inX, indexing)
    discrepancies = [0]*n
    for i in range(n):
        if i in exceptional:
            discrepancies[i] = coefficients[exceptional.index(i)] 
    # print(discrepancies)
    M = inter_mat(self_inter, adj, indexing)
    ample = True
    for i in inX:
        # print(M[i-indexing])
        # print(dot(discrepancies,M[i-indexing]))
        kc =  - 2 - self_inter[i-indexing] - np.dot(discrepancies,M[i-indexing])
        s = 'K_X . C_' + str(i) + ' = ' + str(kc)
        print(s)
        if kc <= 0:
            ample = False
    print("")
    print("Ample: ",ample)
    return ample
    # print(arr)

def printinfo(self_inter, adj, inX, indexing=1):
    M = inter_mat(self_inter,adj,indexing)
    print("Intersection matrix = ", M)
    negative_definite = True
    for x in np.linalg.eig(M)[0]:
        if x >= 0:
           negative_definite = False 
    print("Negative Definite: ", negative_definite, end = '\n\n')
    if negative_definite:
        giveKY(self_inter, adj)
        giveKX(self_inter, adj, inX)
        print("")
        print("Pullback of K_X under π:Y -> X", end = '\n\n')
        checkAmple(self_inter, adj, inX, indexing)

# M = [[-4,0,0,1,1,1],[0,-4,0,1,0,0],[0,0,-4,0,1,0],[1,1,0,-1,0,0],[1,0,1,0,-1,0],[1,0,0,0,0,-1]]
# M = [[-4,0,1,1,1],[0,-4,1,0,0],[1,1,-1,0,0],[1,0,0,-1,0],[1,0,0,0,-1]] 
# print(f(M))
# coeff(M)

####### Example 1

# self_inter = [-1,-1,-1]
# adj = [[2,3],[1,3],[1,2]]
# printinfo(self_inter, adj, [1,2,3])

####### Example 2

# self_inter = [-1,-1,-1, -4]
# adj = [[4],[4],[4],[1,2,3]]
# printinfo(self_inter, adj, [1,2,3])

####### Example 3

# self_inter = [-1,-1,-1, -4, -4]
# adj = [[4,5],[4],[4],[1,2,3],[1]]
# printinfo(self_inter, adj, [1,2,3])

####### Example 3.5

# self_inter = [-1,-1,-1, -4, -4, -4]
# adj = [[4,5],[4,6],[4],[1,2,3],[1], [2]]
# printinfo(self_inter, adj, [1,2,3])

####### Example 4

# self_inter = [-1,-1,-1, -4, -4, -4, -4]
# adj = [[4,5],[4,6],[4,7],[1,2,3],[1],[2],[3]]
# printinfo(self_inter, adj, [1,2,3])

####### Example 5

# self_inter = [-1, -1, -1, -4, -4, -4, -4, -4]
# adj = [[4,5, 8],[4,6],[4,7],[1,2,3],[1],[2],[3], [1]]
# printinfo(self_inter, adj, [1,2,3])

####### Example 6

# self_inter = [-1, -1, -1, -4, -4, -4, -4, -4, -4, -4]
# adj = [[4,5,8],[4,6, 9],[4,7, 10],[1,2,3],[1],[2],[3], [1], [2], [3]]
# printinfo(self_inter, adj, [1,2,3])

######## Example 7

# self_inter = [-1,-1,-1,-2,-5,-4]
# adj = [[5,6],[6],[6],[5],[4,1],[1,2,3]]
# printinfo(self_inter, adj, [1,2,3])

######## Example 8

# self_inter = [-1,-1,-1,-2,-5,-4,-4]
# adj = [[5,6],[6,7],[6],[5],[4,1],[1,2,3],[2]]
# printinfo(self_inter, adj, [1,2,3])

######## Example 9

# self_inter = [-1,-1,-1,-2,-5,-4,-4,-4]
# adj = [[5,6],[6,7],[6,8],[5],[4,1],[1,2,3],[2],[3]]
# printinfo(self_inter, adj, [1,2,3])

######## Example 10

# self_inter = [-1,-1,-1,-2,-5,-4,-4,-4, -4]
# adj = [[5,6],[6,7,9],[6,8],[5],[4,1],[1,2,3],[2],[3],[2]]
# printinfo(self_inter, adj, [1,2,3])

######## Example 11

# self_inter = [-1,-1,-1,-4,-2,-5,-2,-5]
# adj = [[4,6],[4,8],[4],[1,2,3],[5],[1,5],[8],[2,7]]
# printinfo(self_inter, adj, [1,2,3])

######## Example 11

# self_inter = [-1,-1,-1,-4,-2,-5,-4]
# adj = [[4,6,7],[4],[4],[1,2,3],[5],[1,5],[1]]
# printinfo(self_inter, adj, [1,2,3])

######## Example 12

# self_inter = [-1,-1,-1,-5,-2]
# adj = [[4],[4],[4],[5],[4]]
# printinfo(self_inter, adj, [1,2,3])

######## Example 13

self_inter = [-1,-1,-1,-5,-2,-4,-4,-4]
adj = [[4,6],[4,7],[4,8],[5],[4],[1],[2],[3]]
printinfo(self_inter, adj, [1,2,3])

self_inter = [-3,-3,-3,-2,-2]
adj = [[4],[4],[4],[5],[4]]
printinfo(self_inter, adj, [1,2,3])
