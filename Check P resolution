import numpy as np
import fractions

# asumes a, b are 1 x n arrays
def dot(a, b):
    return sum([a[i]*b[i] for i in range(len(a))])

def solve_in_rationals(A: np.ndarray, b: np.ndarray):
    d = int(np.rint(np.linalg.det(A)))
    sol = []
    for i in range(np.shape(A)[0]):
        Ai = np.copy(A)
        Ai[:, i] = b
        t = fractions.Fraction(int(np.rint(np.linalg.det(Ai))), d)
        sol.append(t.numerator)
        # sol.append((str(t.numerator) + '/' + str(t.denominator)))
    return [sol, t.denominator]

'''
CLASS SURFACE:
Surface Y with a map π:Y -> X is resolution of singularities of X 
(the map π is useful only when X is p-resolution and Y is its resolution)
Attributes:
    1. self_inter: Self intersection numbers
    2. adj: adjacency list
    3. num_curves: number of curves
    4. indexing: 0 or 1 indexed
    5. inX: list of curves that are in X (under Y -> X)
    6. M: intersection matrix
Main Methods:
    1. giveKY, giveKX: print K_Y, K_X 
    2. pullbackK: print π*(K_X)
    3. discrepancies: returns discrepancies of Y -> X
    4. checkAmple: return True if π-ample
    5. pFundamentalCycle: prints fundamental cycle
    6. isRational: checks if rational
    7. printinfo: prints all relevant information (e.g. checks if matrix negative definite) 
'''
class surface():
    def __init__(self, self_inter, adj, inX=-1, indexing=1):
        self.self_inter = self_inter
        self.adj = adj
        self.num_curves = len(self_inter)
        self.indexing = indexing # if our curves are 0 or 1 indexed
        if inX == -1:
            self.inX = [i+indexing for i in range(self.num_curves)] # everything is in X if nothing mentioned
        else:
            self.inX = inX # inX has indices of curves that are in X
        self.M = self.inter_mat()
    ''' 
    create intersection matrix
    [[2,3],[1],[2]] is the matrix [X^2,1,1],[1,Y^2,0],[0,1,Z^2]
    NOTE: CAN CONTROL INDEXING by changing last parameter to 0
    '''
    def inter_mat(self):
        n = self.num_curves
        M = [[0]*n for i in range(n)]
        for i in range(n):
            M[i][i] = self.self_inter[i]
        for i in range(n):
            for x in adj[i]:
                M[i][x-self.indexing] = 1
        return M

    '''
    returns column vector [K.C1, K.C_2, ...] = [-C_1^2 - 2, - C_2^2 - 2, ...]
    '''
    def f(self):
        return [-2-self.M[i][i] for i in range(len(self.M))]

    def coeff(self):
        A = np.array(self.M); B = np.array(self.f(self.M)) # Solve Ax = B
        d = np.linalg.det(A)
        sol = np.linalg.solve(d*A, B)
        # sol, d = solve_in_rationals(A,B) 
        return [sol, d]

    '''
    auxiliar function to print coefficieints K_Y or K_X
    surface: X or Y (here Y -> X is a resolution)
    list_of_curves : which curves are in the surface
    '''
    def pcoeff(self, surface, list_of_curves):
        A = np.array(self.M); B = np.array(self.f()) # Solve Ax = B
        d = int(np.linalg.det(A))
        sol = np.linalg.solve((1/d)*A, B)
        sol = [fractions.Fraction(int(np.rint(x)), d) for x in sol]
        # sol, denom = solve_in_rationals(np.array(M),np.array(f(M)))
        s = 'K_' + surface + ' = ('
        for i in range(len(sol)):
            if surface == 'X' and not i+self.indexing in list_of_curves:
                continue
            s += str(sol[i]) + 'C_' + str(i+self.indexing) + ' + '
        s = s[:-3]
        s += ')'
        print(s)

    ''' 
    resolution Y -> X
    neatly prints something like K = 1/5(2C_1 + 3C_2) 
    '''
    def giveKY(self):
        return self.pcoeff('Y', [])

    # KX, prints after contracting all non (-1) curves in Y
    def giveKX(self): 
        return self.pcoeff('X', self.inX)

    '''
    Find π^*(K_X)
    '''
    def pullbackK(self):
        n = self.num_curves
        exceptional = [i for i in range(n) if not (i+self.indexing) in self.inX] # exceptional is 0 indexed
        m = len(exceptional)
        M = [[0]*m for i in range(m)]
        for i in range(m):
            M[i][i] = self.self_inter[exceptional[i]]
        for i in range(m):
            for x in adj[exceptional[i]]:
                if x-self.indexing in exceptional:
                    # print(i, exceptional.index(x))
                    M[i][exceptional.index(x-self.indexing)] = 1  
        A = np.array(M)
        B = np.array([self.f()[i] for i in range(self.num_curves) if i in exceptional])
        # Solve Ax = B
        d = np.linalg.det(A)
        try: ## In case exceptional locus is empty
            d = int(np.linalg.det(A))
            sol = np.linalg.solve((1/d)*A, B)
            sol = [fractions.Fraction(int(np.rint(x)), d) for x in sol]
        except:
            print("Some issue")
            d = 1
            sol = []
            
        s = 'K_Y = π^* K_X + '
        for i in range(len(sol)):
            s += str(sol[i]) + 'C_' + str(exceptional[i]+self.indexing) + ' + '
        if len(sol) > 0:
            s = s[:-3]
            print(s) # prints equation
        return sol # returns array of coefficients
    
    def discrepancies(self):
        n = self.num_curves
        exceptional = [i for i in range(n) if not (i+self.indexing) in self.inX] # exceptional is 0 indexed
        coefficients = self.pullbackK()
        discrepancies = [0]*n
        for i in range(n):
            if i in exceptional:
                discrepancies[i] = coefficients[exceptional.index(i)] 
        return discrepancies

    def checkAmple(self):
        discrepancies = self.discrepancies()
        # print(discrepancies)
        M = self.inter_mat()
        ample = True
        for i in self.inX:
            # print(M[i-indexing])
            # print(dot(discrepancies,M[i-indexing]))
            kc =  - 2 - self.self_inter[i-self.indexing] - np.dot(discrepancies,M[i-self.indexing])
            s = 'K_X . C_' + str(i) + ' = ' + str(kc)
            print(s)
            if kc <= 0:
                ample = False
        print("")
        print("π-Ample: ",ample)
        return ample
        # print(arr)

    '''
    Intersection Product:
        Given two divisors 
            D_1 = a_1C_1 + ... + a_nC_n as [a_1,...,a_n] and
            D_2 = b_1C_1 + ... + b_nC_n as [b_1,...,b_n] 
        Find D_1 . D_2
    '''

    def intersectionProduct(self,D1, D2):
        return np.matmul(np.matmul(np.transpose(D1), self.M), D2)

    '''
    Check if Rational using Artin's Criteria
    1. Find Fundamental Cycle Z
    2. Check if p_Z = 0
    '''

    ## Check if Z is a negative cycle, Z given as a list of coefficients
    ## return True or False
    ## If false, also returns lowest (0) index of curve where it fails
    def isNegativeCycle(self, coeff):
        for k in range(self.num_curves):
            ZdotC = sum([coeff[i]*self.M[i][k] for i in range(self.num_curves)])
            if ZdotC > 0:
                return [False, k]
        return [True, None]

    ## Find fundamental cycle Z, a list of coefficients
    def fundamentalCycle(self):
        coeff = [1]*len(self_inter)
        while not self.isNegativeCycle(coeff)[0]:
            k = self.isNegativeCycle(coeff)[1] 
            coeff[k] += 1
        return coeff

    ## Print Fundamental cycle
    def pFundamentalCycle(self):
        coeff = self.fundamentalCycle()
        s = "Z = "
        for i in range(len(coeff)):
            s += str(coeff[i]) + 'C_' + str(i+1) + ' + '
        s = s[:-2]
        print(s) 

    ## check if rational
    def isRational(self):
        Z = self.fundamentalCycle()
        # adj = (K+Z) . Z
        adj = sum([Z[i] * (-2-self.self_inter[i]) for i in range(self.num_curves)]) + self.intersectionProduct(Z,Z)
        # arithematic genus
        pz = (adj+2)/2
        if int(pz)-pz != 0:
            print('WEIRD ISSUE, p_Z is not an integer?!')
        if pz == 0:
            return "True"
        return "False, p_Z = " + str(int(pz))

    def printinfo(self):
        print("Intersection matrix = ", self.M)
        negative_definite = True
        for x in np.linalg.eig(self.M)[0]:
            if x >= 0:
                negative_definite = False 
        print("Negative Definite: ", negative_definite, end = '\n\n')
        if negative_definite:
            self.giveKY()
            print("")

            ## if X = Y, then π is silly and useless
            if len(self.inX) < self.num_curves:
                self.giveKX()
                print("")
                print("Pullback of K_X under π:Y -> X", end = '\n\n')
                self.checkAmple()
            print("Fundamental cycle: ", end = ' ')
            self.pFundamentalCycle()
            print("")
            print("Rational: ", self.isRational())



# M = [[-4,0,0,1,1,1],[0,-4,0,1,0,0],[0,0,-4,0,1,0],[1,1,0,-1,0,0],[1,0,1,0,-1,0],[1,0,0,0,0,-1]]
# M = [[-4,0,1,1,1],[0,-4,1,0,0],[1,1,-1,0,0],[1,0,0,-1,0],[1,0,0,0,-1]] 
# print(f(M))
# coeff(M)

####### Example 1

# self_inter = [-1,-1,-1]
# adj = [[2,3],[1,3],[1,2]]
# printinfo(self_inter, adj, [1,2,3])

####### Example 2

# self_inter = [-1,-1,-1, -4]
# adj = [[4],[4],[4],[1,2,3]]
# printinfo(self_inter, adj, [1,2,3])

####### Example 3

# self_inter = [-1,-1,-1, -4, -4]
# adj = [[4,5],[4],[4],[1,2,3],[1]]
# printinfo(self_inter, adj, [1,2,3])

####### Example 3.5

# self_inter = [-1,-1,-1, -4, -4, -4]
# adj = [[4,5],[4,6],[4],[1,2,3],[1], [2]]
# printinfo(self_inter, adj, [1,2,3])

####### Example 4

# self_inter = [-1,-1,-1, -4, -4, -4, -4]
# adj = [[4,5],[4,6],[4,7],[1,2,3],[1],[2],[3]]
# printinfo(self_inter, adj, [1,2,3])

####### Example 5

# self_inter = [-1, -1, -1, -4, -4, -4, -4, -4]
# adj = [[4,5, 8],[4,6],[4,7],[1,2,3],[1],[2],[3], [1]]
# printinfo(self_inter, adj, [1,2,3])

####### Example 6

# self_inter = [-1, -1, -1, -4, -4, -4, -4, -4, -4, -4]
# adj = [[4,5,8],[4,6, 9],[4,7, 10],[1,2,3],[1],[2],[3], [1], [2], [3]]
# printinfo(self_inter, adj, [1,2,3])

######## Example 7

# self_inter = [-1,-1,-1,-2,-5,-4]
# adj = [[5,6],[6],[6],[5],[4,1],[1,2,3]]
# printinfo(self_inter, adj, [1,2,3])

######## Example 8

# self_inter = [-1,-1,-1,-2,-5,-4,-4]
# adj = [[5,6],[6,7],[6],[5],[4,1],[1,2,3],[2]]
# printinfo(self_inter, adj, [1,2,3])

######## Example 9

# self_inter = [-1,-1,-1,-2,-5,-4,-4,-4]
# adj = [[5,6],[6,7],[6,8],[5],[4,1],[1,2,3],[2],[3]]
# printinfo(self_inter, adj, [1,2,3])

######## Example 10

# self_inter = [-1,-1,-1,-2,-5,-4,-4,-4, -4]
# adj = [[5,6],[6,7,9],[6,8],[5],[4,1],[1,2,3],[2],[3],[2]]
# printinfo(self_inter, adj, [1,2,3])

######## Example 11

# self_inter = [-1,-1,-1,-4,-2,-5,-2,-5]
# adj = [[4,6],[4,8],[4],[1,2,3],[5],[1,5],[8],[2,7]]
# printinfo(self_inter, adj, [1,2,3])

######## Example 11

# self_inter = [-1,-1,-1,-4,-2,-5,-4]
# adj = [[4,6,7],[4],[4],[1,2,3],[5],[1,5],[1]]
# printinfo(self_inter, adj, [1,2,3])

######## Example 12

# self_inter = [-1,-1,-1,-5,-2]
# adj = [[4],[4],[4],[5],[4]]
# printinfo(self_inter, adj, [1,2,3])

######## Example 13

# self_inter = [-1,-1,-1,-5,-2,-4,-4,-4]
# adj = [[4,6],[4,7],[4,8],[5],[4],[1],[2],[3]]
# printinfo(self_inter, adj, [1,2,3])

# self_inter = [-3,-3,-3,-2,-2]
# adj = [[4],[4],[4],[5],[4]]
# printinfo(self_inter, adj, [1,2,3])

'''Rational test'''

######## FORK 1
## 2 - 1 - 4
##     |
##     3  
## All self intersection (-2)

# self_inter = [-2,-2,-2,-2]
# adj = [[2,3,4],[1],[1],[1]]
# pFundamentalCycle(self_inter,adj)

######## FORK 2
## 2 - 1 - 4
##     |
##     3  
## All self intersection (-2) except 1

# self_inter = [-3,-3,-3,-3]
# adj = [[2,3,4],[1],[1],[1]]
# Y = surface(self_inter,adj)
# Y.printinfo()

######## FORK 3, example of not rational 
## 2 - 1 - 5
##    / \
##   3   4
## All self intersection (-2) except 1

# self_inter = [-2,-3,-3,-3,-3]
# adj = [[2,3,4,5],[1],[1],[1],[1]]
# Y = surface(self_inter,adj)
# Y.printinfo()

######## Cyclic quotient singularity example
##### Left one (see ipad diagram)
# self_inter = [-2,-5,-1,-4]
# adj = [[2],[1,3],[2,4],[3]]
# inX = [3]
# Y = surface(self_inter,adj,inX=inX)
# Y.printinfo()

##### Right one (see ipad diagram)
self_inter = [-2,-4,-3]
adj = [[2],[1,3],[2]]
inX = [1,3]
Y = surface(self_inter,adj,inX=inX)
Y.printinfo()

